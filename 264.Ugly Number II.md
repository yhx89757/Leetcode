# 基本思路
这道题很精妙，你看着它好像是道数学题，实际上它却是一个合并多个有序链表的问题，同时用到了筛选素数的思路。

建议你先做一下链表双指针技巧汇总 中讲到的 21. 合并两个有序链表（简单），然后再做一下 如何高效寻找素数 中讲的 204. 计数质数（简单），这样的话就能比较容易理解这道题的思路了。

类似如何高效寻找素数的思路：如果一个数 x 是丑数，那么 x * 2, x * 3, x * 5 都一定是丑数。

我们把所有丑数想象成一个从小到大排序的链表, 然后，我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数（按照题目的意思，1 算作特殊的丑数，放在开头），这三类丑数就好像三条有序链表.

我们其实就是想把这三条「有序链表」合并在一起并去重，合并的结果就是丑数的序列。然后求合并后的这条有序链表中第 n 个元素是什么。所以这里就和
链表双指针技巧汇总 中讲到的合并 k 条有序链表的思路基本一样了。

具体思路看注释吧，你也可以对照我在 21. 合并两个有序链表（简单） 中给出的思路代码来看本题的思路代码，就能轻松看懂本题的解法代码了。

## 多指针
```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        # 可以理解为三个指向有序链表头结点的指针
        p2, p3, p5 = 1, 1, 1
        # 可以理解为三个有序链表的头节点的值
        product2, product3, product5 = 1, 1, 1
        # 可以理解为最终合并的有序链表（结果链表）
        ugly = [0] * (n + 1)
        # 可以理解为结果链表上的指针
        p = 1

        # 开始合并三个有序链表
        while p <= n:
            # 取三个链表的最小结点
            min_val = min(product2, product3, product5)
            # 接到结果链表上
            ugly[p] = min_val
            p += 1
            # 前进对应有序链表上的指针
            if min_val == product2:
                # 因为丑数是只包含2,3,5,所以是 2 * ugly[p2] 而不是 2 * p2
                product2 = 2 * ugly[p2]
                p2 += 1
            if min_val == product3:
                product3 = 3 * ugly[p3]
                p3 += 1
            if min_val == product5:
                product5 = 5 * ugly[p5]
                p5 += 1
         # 返回第 n 个丑数
        return ugly[n]
```
